use File::Spec;
use warnings;

require "app_transform.pl";

#GENERATORS

sub generate_config_xml{
	return generate_xml_appconf($configfile, $INC[$#INC].'/../ciaoApp.scheme.pl');
}
sub generate_arch_makefile{
	return "ARCH := $arch\n";
}

sub generate_irq_map {
	# minimum generated entry in the vector table
	my %min_gen_entry = (
		'_armcortex' => 3,
	);
	my $rfm = read_config($configfile);
	my %fm = %$rfm;
	my ($key,$val);
	my $forward = '';

	my $irqmax=0;
	my $irq_cat2_max= (exists $rfm->{'cfIRQ_CAT2_ISR_MAX'}) ? $rfm->{'cfIRQ_CAT2_ISR_MAX'} : 1;

	my %level_2_name = ( );

	#forward declarations
	$forward .= "#ifdef __cplusplus\n";
	$forward .= "namespace hw { namespace irq {\n";
	while( ($key,$val) =each %$rfm){
		if ($key =~ m/^cfIRQL_/ && $val != 0) {
			my $irqname = $';
			#detect maximum IRQ level
			$irqmax = $val if $irqmax<$val;

			#forward declaration
			$forward.=<<"end";
		struct $irqname {
				static Bool cfHAL_IRQHANDLER_ATTRIBUTES HWHandler();
		};
end
			$level_2_name{$val} = [ ] unless exists $level_2_name{$val};
			push @{$level_2_name{$val}}, $irqname;
		}
	}
	$forward .= "}}\n";
	$forward .= "#endif\n";

	#generate irqmap
	my $irqmap="\nIRQ_ENTRIES_BEGIN\n";
	my $irqname='';
	my $irql = (exists $min_gen_entry{$arch}) ? $min_gen_entry{$arch} : 1;
	for (; $irql <= $irqmax;  $irql++) {
		if(exists $level_2_name{$irql} and not $irq_cat2_max==-1) {
			if(@{$level_2_name{$irql}} > 1) {
				die "multiple ISRs defined for level $irql: " . (join(',', @{$level_2_name{$irql}})) . "\n";
			}
			my $irqname = $level_2_name{$irql}->[0];
			if ($irql > $irq_cat2_max){
				$irqmap.= "IRQ_ENTRY($irql,$irqname)\n";
			} else {
				$irqmap.= "IRQ_CAT2ENTRY($irql,$irqname,$irq_cat2_max)\n";
			}
		} else {
			$irqmap.= "IRQ_NOENTRY($irql)\n";
		}
	}

	$irqmap.="IRQ_ENTRIES_END\n#endif //__GENERATE_IRQTABLE__\n";

	#generate final output
	my $hfile='';
	$hfile.= "//this file is generated by kconf/common/scripts/generators.pl::generate_irq_map()\n";
	$hfile.= "#define cfIRQL_MAX $irqmax\n\n";
	$hfile.= "#define cfIRQL_CAT2_ISR_MAX $irq_cat2_max\n\n";
	$hfile.='#ifdef __GENERATE_IRQTABLE__'."\n\n";
	$hfile.= $forward;
	$hfile.= $irqmap;
	return $hfile;
}

sub inifield {
	my $fname=shift;
	my $ename=shift;
	my $rfm = read_config($configfile);
	my %fm = %$rfm;

	if(exists $fm{$ename}){
		return ",$fname";
	}
}
sub inifield_nocomma{
	my $fname=shift;
	my $ename=shift;
	my $rfm = read_config($configfile);
	my %fm = %$rfm;
	if(exists $fm{$ename}){
		return "$fname";
	}
}

sub staticInitializerMacros(){
	my $rfm = read_config($configfile);
	my %fm = %$rfm;
	my $ret=helper_cfInitializers(); #os com compat, to be removed
	$ret.="//generated by p::v\n";
	$ret.="\n#define TASK_INITIALIZER(priority,state,function,stack,interrupted,application, \\\n";
	$ret.="occupied_resources,original_priority,stacksize,current_activations,max_activations, \\\n";
	$ret.="current_events,events_waited_for,preemptable, \\\n";
	$ret.="current_application,current_stack_h,stack_l,transitions_to_nt,acl_l,acl_h, \\\n";
	$ret.="ar_timeframe,ar_allowed,executiontimebudget,etb_deadline,currentexecutiontimebudget,  \\\n";
	$ret.="isrlockbudget,isrlockisrid,isrlockdeadline,  \\\n";
	$ret.="resourcelockbudget,resourcelockresid,resourcelockdeadline) \\\n";
	$ret.="{priority,state,function,stack,interrupted";
	$ret.=inifield('application','');
	$ret.=inifield('application','kernel_applications');
	$ret.=inifield('occupied_resources,original_priority','kernel_resources');
	$ret.=inifield('stacksize','autosar_stackmonitoring');
	$ret.=inifield('current_activations','kernel_multipleactivation');
	$ret.=inifield('max_activations','max_activations_check');
	$ret.=inifield('current_events,events_waited_for','kernel_events');
	$ret.=inifield('preemptable','kernel_mixedpreemptive');

	$ret.=inifield('current_application,current_stack_h','memprot_ntf');
	if(exists $fm{'memprot_stacks'} or exists $fm{'memprot_ntf'} or (exists $fm{'memprot_trusted'} and exists $fm{'cfOS_ISR2_SUPPORT'})){
		$ret.=',stack_l';
	}
	if((!exists $fm{'memprot_stacks'}) and exists $fm{'memprot_ntf'}){
		$ret.=',transitions_to_nt';
	}
	if(exists $fm{'kernel_messageports_receiverwriteaccess'} or exists $fm{'kernel_messageports_senderwriterevocation'}) {
		$ret.=',acl_l,acl_h';
	}

	$ret.=inifield('ar_timeframe,ar_allowed','timeprot_AR_Tasks');
	$ret.=inifield('executiontimebudget,etb_deadline,currentexecutiontimebudget','timeprot_ETB_Tasks');
	$ret.=inifield('isrlockbudget,isrlockisrid,isrlockdeadline','timeprot_LTB_ISR_Tasks');
	$ret.=inifield('resourcelockbudget,resourcelockresid,resourcelockdeadline','timeprot_LTB_Resource_Tasks');
	$ret.="}\n";
	$ret.="\n#define ISR_INITIALIZER(funcname,sourceid,osapplication,executionbudget,executiondeadline,ar_timeframe,ar_allowed,isrlockbudget,lockedisrid,isrlockdeadline,resourcelockbudget,lockedresid,resourcelockdeadline) \\\n";
	$ret.="{funcname,sourceid,osapplication";
	$ret.=inifield('executionbudget,executiondeadline','timeprot_ETB_ISR2');
	$ret.=inifield('ar_timeframe,ar_allowed','timeprot_AR_ISR2');
	$ret.=inifield('isrlockbudget,lockedisrid,isrlockdeadline','timeprot_LTB_ISR_ISR2');
	$ret.=inifield('resourcelockbudget,lockedisrid,resourcelockdeadline','timeprot_LTB_Resource_ISR2');
	$ret.="}\n";

	# Application initializer macro
	$ret.="\n#define APPLICATION_INITIALIZER(trusted, data_l,data_u,stacks_l,code_l,code_u,defact,defeve) \\\n{trusted";

	if(exists $fm{'memprot_apps'}) { # Isolation of non-trusted apps among each other
		if(exists $fm{'memprot_data'}) { # Private data segments

			# if stack protection is disabled, include all stacks in the private data seg
			$ret .= exists $fm{'memprot_stacks'} ? ',data_l' : ',stacks_l';

			$ret .= ',data_u';
		}

		if(exists $fm{'memprot_code'}) {
			$ret .= ',code_l,code_u';
		}
	}

	$ret .= ',defact' if exists $fm{'memprot_deferact'};
	$ret .= ',defeve' if exists $fm{'memprot_defereve'};
	$ret.="}\n";

	return $ret;
}

sub generate_attribute_file{
	my $rfm = read_config($configfile);
	my %fm = %$rfm;
	my ($key,$val);
	my $ret='';
	while( ($key,$val) =each %$rfm){
		if($key =~ m/^cf/){
			$ret.="#define $key $val\n";
		}
	}

	$ret .= "\n#include \"cfAppAttribs.h\"\n";

	return $ret;
}

sub generate_network_config {
	my $retVal =<<eofjs;
#ifndef __CIAO_NETWORK_CONFIG_H__
#define __CIAO_NETWORK_CONFIG_H__

#define subnetMask 255,255,255,0

#define __byte_swap2(val) \\
    ((((val) & 0xff) << 8) | \\
     (((val) & 0xff00) >> 8))

#define __byte_swap4(val) \\
    ((((val) & 0xff) << 24) | \\
     (((val) & 0xff00) << 8) | \\
     (((val) & 0xff0000) >> 8) | \\
     (((val) & 0xff000000) >> 24))

#define htons(x) __byte_swap2(x)
#define htonl(x) __byte_swap4(x)
#define ntohs(x) __byte_swap2(x)
#define ntohl(x) __byte_swap4(x)

eofjs
	my $rfm = read_config($configfile);
	if ( defined $rfm->{network_config_ip} && defined $rfm->{network_config_mac} ) {
		if ( $rfm->{network_config_ip} =~ /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/ ) {
			$retVal .= "#define cfIpAddress $1,$2,$3,$4\n";
		} else {
			die "IP address " . $rfm->{network_config_ip} . " is in wrong format";
		}
		if ( $rfm->{network_config_ip_basestation} =~ /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/ ) {
			$retVal .= "#define cfPeerIpAddress $1,$2,$3,$4\n";
		} else {
			die "IP address " . $rfm->{network_config_ip} . " is in wrong format";
		}
		if ( $rfm->{network_config_mac} =~ /([0-9A-Fa-f]{1,2}):([0-9A-Fa-f]{1,2}):([0-9A-Fa-f]{1,2}):([0-9A-Fa-f]{1,2}):([0-9A-Fa-f]{1,2}):([0-9A-Fa-f]{1,2})/ ) {
			$retVal .= "#define cfmacAddress 0x$1$2$3$4$5$6ULL\n";
		} else {
			die "MAC address " . $rfm->{network_config_mac} . " is in wrong format";
		}
	}
$retVal .=<<eofjs;

#endif // __CIAO_NETWORK_CONFIG_H__
eofjs
	return $retVal;
}


sub alias_text{
#	#ifndef __pv_guard_iJ2NiUXRV__hUIrsb_i5_22UTbM9qLhes20
#	#define __pv_guard_iJ2NiUXRV__hUIrsb_i5_22UTbM9qLhes20
#	#include "/home/cip/2006/sirahack/ciao/config/tc_triboard1796/os/src/hw/dev/ASC.h"
#	namespace hw {
#	namespace hal {
#	typedef ::hw::dev::ASC0 DebugPortImpl;
#	}
#	}
#	#endif


	my $path=shift;
	my $classname=shift;
	my $newname=shift;
	my $namespacelist=shift;
	my @l=@$namespacelist;
	my $guard=shift;

	my $depth=0;
	my $i=0;

#	my $fullpath= "$env{'target_root'}/$path";
#	my $abspath=File::Spec->rel2abs($fullpath);

	my $ret='';
	$ret.="#ifndef $guard\n";
	$ret.="#define $guard\n";
	$ret.="#include \"$path\"\n";
	$ret.="namespace $l[0] {\n";
	$ret.="namespace $l[1] {\n";
	$ret.="typedef $classname $newname;\n";
	$ret.="}\n";
	$ret.="}\n";
	$ret.="#endif\n";
	return $ret;
}

sub alias{
	my $mapref=shift;
	my %map=%$mapref;
	my @l=@$map{'nsl'};
	#print "innen:$self{'file'}\n";

	my $incpath = (exists $map{incpath}) ? $map{incpath} : $map{path};
	alias_text($incpath,$map{'classname'},$map{'newname'},$map{'nsl'},$map{'guard'});

}

#END: GENERATORS
#pseudo helper function: TODO: REPLACE

sub helper_cfFlags{
	my $ret='';
	$ret.=<<"finitum2";
#ifndef __pv_guard_izz6Ydr1tttOTsjzD_iTlL7ClTmLUWQxUHG
#define __pv_guard_izz6Ydr1tttOTsjzD_iTlL7ClTmLUWQxUHG
#undef cfHAL_IRQHANDLER_ATTRIBUTES
#define cfHAL_IRQHANDLER_ATTRIBUTES __attribute__((interrupt))
#endif
#ifndef __pv_guard_imQ6Ce9qEzaYA8uAD_iPQeMkBrC0rMrDyE1
#define __pv_guard_imQ6Ce9qEzaYA8uAD_iPQeMkBrC0rMrDyE1
#undef cfHAL_TRAPHANDLER_ATTRIBUTES
#define cfHAL_TRAPHANDLER_ATTRIBUTES __attribute__((interrupt)) __attribute__((section(".ciao_traptab.handler")))
#endif
finitum2
	return $ret;

}
sub helper_cfInitializers{
	my $ret='';
	$ret.=<<"finitum1";
#define OS_COM_ASCOM_CONFIG_INITIALIZER(RxSigs, NumRxSigs, RxSigGroups, NumRxSigGroups, RxIpdus, NumRxIpdus, RxIpduGroups, NumRxIpduGroups, TxSigs, NumTxSigs, TxSigGroups, NumTxSigGroups, TxIpdus, NumTxIpdus, TxIpduGroups, NumTxIpduGroups) \\
{}

#define OS_COM_ASCOM_RX_IPDU_GROUP_CONFIG_INITIALIZER(IpduIdMin, IpduIdMax) \\
{}

#define OS_COM_ASCOM_TX_IPDU_GROUP_CONFIG_INITIALIZER(IpduIdMin, IpduIdMax) \\
{}

#define OS_COM_ASCOM_RX_IPDU_CONFIG_INITIALIZER(IpduGroupId, MinSignalId, MaxSignalId, MinSignalGroupId, MaxSignalGroupId, Length, Callout, DMTimeoutFactor) \\
{}

#define OS_COM_ASCOM_TX_IPDU_CONFIG_INITIALIZER(IpduGroupId,MinSignalId,MaxSignalId,MinSignalGroupId,MaxSignalGroupId,Length,Callout,MDTimeFactor,DMFirstTimeout,DMTimeout,TMSEnabled,TM,Period,Offset,TMAlt,PeriodAlt,OffsetAlt) \\
{}

#define OS_COM_ASCOM_TX_SIGNAL_CONFIG_INITIALIZER_INTERNAL(IpduId, Nature, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, TransferProperty, FilterAlgo, FilterX, FilterY) \\
{}

#define OS_COM_ASCOM_TX_SIGNAL_CONFIG_INITIALIZER(IpduId, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, TransferProperty, FilterAlgo, FilterX, FilterY) \\
OS_COM_ASCOM_TX_SIGNAL_CONFIG_INITIALIZER_INTERNAL(IpduId, SIGNAL, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, TransferProperty, FilterAlgo, FilterX, FilterY)

#define OS_COM_ASCOM_TX_GROUP_SIGNAL_CONFIG_INITIALIZER(IpduId, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex) \\
OS_COM_ASCOM_TX_SIGNAL_CONFIG_INITIALIZER_INTERNAL(IpduId, GROUP_SIGNAL, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, PENDING, Always, 0, 0)

#define OS_COM_ASCOM_TX_LAST_GROUP_SIGNAL_CONFIG_INITIALIZER(IpduId, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, TransferProperty) \\
OS_COM_ASCOM_TX_SIGNAL_CONFIG_INITIALIZER_INTERNAL(IpduId, GROUP_SIGNAL, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, TransferProperty, Always, 0, 0)

#define OS_COM_ASCOM_TX_SIGNAL_GROUP_CONFIG_INITIALIZER(IpduId, SignalIdMin, SignalIdMax) \\
{}

#define OS_COM_ASCOM_RX_SIGNAL_CONFIG_INITIALIZER_INTERNAL(IpduId, Nature, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, FilterAlgo, FilterX, FilterY) \\
{}

#define OS_COM_ASCOM_RX_SIGNAL_CONFIG_INITIALIZER(IpduId, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, FilterAlgo, FilterX, FilterY) \\
OS_COM_ASCOM_RX_SIGNAL_CONFIG_INITIALIZER_INTERNAL(IpduId, SIGNAL, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, FilterAlgo, FilterX, FilterY)

#define OS_COM_ASCOM_RX_GROUP_SIGNAL_CONFIG_INITIALIZER(IpduId, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex) \\
OS_COM_ASCOM_RX_SIGNAL_CONFIG_INITIALIZER_INTERNAL(IpduId, GROUP_SIGNAL, Type, LsByteIndex, MsByteIndex, LsBitIndex, MsBitIndex, Always, 0, 0)

#define OS_COM_ASCOM_RX_SIGNAL_GROUP_CONFIG_INITIALIZER(IpduId, RxSignalIdMin, RxSignalIdMax) \\
{}

#define HW_HAL_CAN_RX_LPDU_CONFIG_INITIALIZER(CanId, CanDlc) \\
{}

#define HW_HAL_CAN_CONTROLLER_CONFIG_INITIALIZER(CtrlConfigs, ControllerId, CanDriverHndl) \\
{(CtrlConfigs), (ControllerId)}

#define HW_DEV_CAN_HW_OBJECT_CONFIG_INITIALIZER(Id, Mask, ControllerId, Direction) \\
{{(Id)}, (ControllerId) }

finitum1
	return $ret;

}


sub helper_ciaoHW{
	my $ret='';
	$ret.=<<"fin";
#ifndef __pv_guard_iVGn06wPXdBeqlZmQ_ixbut8aG0AnOkpioV
#define __pv_guard_iVGn06wPXdBeqlZmQ_ixbut8aG0AnOkpioV
#undef ciaoARCH__tc
#define ciaoARCH__tc 1
#endif
#ifndef __pv_guard_irUJUaF1EjwauBBdL_iImuGPwqG0kabB7VN
#define __pv_guard_irUJUaF1EjwauBBdL_iImuGPwqG0kabB7VN
#undef ciaoPLATFORM_triboard1796
#define ciaoPLATFORM_triboard1796 1
#endif
#ifndef __pv_guard_iaAVXHzJoBRN0cb2K_iUylRQqcMEXfi4Gqc
#define __pv_guard_iaAVXHzJoBRN0cb2K_iUylRQqcMEXfi4Gqc
#undef ciaoARCH
#define ciaoARCH _tc
#endif
fin
	return $ret;

}
sub mk_helper {
	my $rfm = read_config($configfile);
	my $ret = "CIAO_LINKFIRST += \$(LIB_DIR)/crt0.o \$(LIB_DIR)/memory.x \$(LIB_DIR)/vectab.x -nostdlib\n";

	unless(exists $rfm->{toolchain_weaveinapp}) {
		$ret .= "APP_COMPILER := CXX\n";
	} else {
		$ret .= "APP_COMPILER := AGXX\n";
		$ret .= "WEAVEINAPP := 1\n";
	}

	return $ret;
}

sub mk_helper_x86{
	my $rfm = read_config($configfile);

	my $ret;
	if(exists $rfm->{platform_native}) {
		$ret = "CIAO_LINKFIRST += \$(LIB_DIR)/crt0.o -T \$(LIB_DIR)/sections.x -nostdlib\n";
	} else { #platform_guest
		$ret = "CIAO_LINKFIRST += \$(LIB_DIR)/crt0.o -nostartfiles\n";
	}

	unless(exists $rfm->{toolchain_weaveinapp}) {
		$ret .= "APP_COMPILER := CXX\n";
	} else {
		$ret .= "APP_COMPILER := AGXX\n";
		$ret .= "WEAVEINAPP := 1\n";
	}

	return $ret;
}
1;
